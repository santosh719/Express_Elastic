{
  "title": "Using StringBuilder/StringBuffer to concatenate strings[edit]",
  "content": "Remember that String objects are immutable objects. Once a String is created, it can not be modified, takes up memory until garbage collected. Be careful of writing a method like this:Code section 3.87: Raw concatenation.\n\n\n1 public String convertToString(Collection<String> words) {\n2   String str = \"\";\n3   // Loops through every element in words collection\n4   for (String word : words) {\n5     str = str + word + \" \";\n6   }\n7   return str;\n8 }On the + operation a new String object is created at each iteration. Suppose words contains the elements [\"Foo\", \"Bar\", \"Bam\", \"Baz\"]. At runtime, the method creates thirteen Strings:\"\"\n\"Foo\"\n\" \"\n\"Foo \"\n\"Foo Bar\"\n\" \"\n\"Foo Bar \"\n\"Foo Bar Bam\"\n\" \"\n\"Foo Bar Bam \"\n\"Foo Bar Bam Baz\"\n\" \"\n\"Foo Bar Bam Baz \"Even though only the last one is actually useful.To avoid unnecessary memory use like this, use the StringBuilder class. It provides similar functionality to Strings, but stores its data in a mutable way. Only one StringBuilder object is created. Also because object creation is time consuming, using StringBuilder produces much faster code.Code section 3.88: Concatenation with StringBuilder.\n\n\n1 public String convertToString(Collection<String> words) {\n2   StringBuilder buf = new StringBuilder();\n3   // Loops through every element in words collection\n4   for (String word : words) {\n5     buf.append(word);\n6     buf.append(\" \");\n7   }\n8   return buf.toString();\n9 }As StringBuilder isn't thread safe (see the chapter on Concurrency) you can't use it in more than one thread. For a multi-thread environment, use StringBuffer instead which does the same and is thread safe. However, StringBuffer is slower so only use it when it is required. Moreover, before Java 5 only StringBuffer existed."
}