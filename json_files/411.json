{
  "title": "To do:",
  "content": "Navigate Reflection topic: (vde)\n\n Reflection Overview\n Dynamic Class Loading\n Dynamic Method Invocation\n Accessing Private Features with ReflectionAll features of a class can be obtained via reflection, including access to private methods & variables. But not always see [1]. Let us look at the following example:Code listing 10.3: Secret.java\n\n\n1 public class Secret {\n2   private String secretCode = \"It's a secret\";\n3  \n4   private String getSecretCode() {\n5     return secretCode;     \n6   }\n7 }Although the field and method are marked private, the following class shows that it is possible to access the private features of a class:Code listing 10.4: Hacker.java\n\n\n 1 import java.lang.reflect.Field;\n 2 import java.lang.reflect.InvocationTargetException;\n 3 import java.lang.reflect.Method;\n 4  \n 5 public class Hacker {\n 6  \n 7    private static final Object[] EMPTY = {};\n 8  \n 9    public void reflect() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n10      Secret instance = new Secret();\n11      Class<?> secretClass = instance.getClass();\n12  \n13      // Print all the method names & execution result\n14      Method methods[] = secretClass.getDeclaredMethods();\n15      System.out.println(\"Access all the methods\");\n16      for (Method method : methods) {\n17         System.out.println(\"Method Name: \" + method.getName());\n18         System.out.println(\"Return type: \" + method.getReturnType());\n19         method.setAccessible(true);\n20         System.out.println(method.invoke(instance, EMPTY) + \"\\n\");\n21      }\n22  \n23      // Print all the field names & values\n24      Field fields[] = secretClass.getDeclaredFields();\n25      System.out.println(\"Access all the fields\");\n26      for (Field field : fields) {\n27         System.out.println(\"Field Name: \" + field.getName());\n28         field.setAccessible(true);\n29         System.out.println(field.get(instance) + \"\\n\");\n30      }\n31   }\n32  \n33   public static void main(String[] args) {\n34     Hacker newHacker = new Hacker();\n35  \n36     try {\n37       newHacker.reflect();\n38     } catch (Exception e) {\n39       e.printStackTrace();\n40     }\n41   }\n42 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 10.4\n\nAccess all the methods\nMethod Name: getSecretCode\nReturn type: class java.lang.String\nIt's a secret\nAccess all the fields\nField Name: secretCode\nIt's a secretJUnit - Test Private methods[edit]JUnit's are unit test cases, used to test the Java programs. Now you know how to test a private method using Reflection in JUnit. There's a long-standing debate on whether testing private members is a good habit[1];There are cases where you want to make sure a class exhibited the right behavior while not making the fields that need checking to assert that public (as it's generally considered bad practice to create accessors to a class just for the sake of a unit test). There are also cases when you can greatly simplify a test case by using reflection to test all smaller private methods (and their various branches), then test the main function. With dp4j it is possible to test private members without directly using the Reflection API but simply accessing them as if they were accessible from the testing method; dp4j injects the needed Reflection code at compile-time[2].What's the best way of unit testing private methods?, March 7, 2011\n Reflection API injected at compile-time"
}