{
  "title": "Creating object by cloning an object[edit]",
  "content": "Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the object's states.You may ask why we need this clone method. Can't we create a constructor, pass in the same object and do the copying variable by variable? An example would be (note that accessing the private memberVar variable of obj is legal as this is in the same class):Code listing 4.14: MyObject.java\n\n\n1 public class MyObject {\n2    private int memberVar;\n3 ...\n4    MyObject(MyObject obj) {\n5       this.memberVar = obj.memberVar;\n6     ...\n7    }\n8 ...\n9 }This method works but object creation with the new keyword is time-consuming. The clone() method copies the whole object's memory in one operation and this is much faster than using the new keyword and copying each variable so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.Code section 4.31: Object cloning.\n\n\n 1 HashTable cacheTemplate = new HashTable();\n 2 ...\n 3 /** Clone Customer object for performance reason */\n 4 public Customer createCustomerObject() {\n 5    // See if a template object exists in our cache\n 6    Customer template = cacheTemplate.get(\"Customer\");\n 7    if (template == null) {\n 8       // Create template\n 9       template = new Customer();\n10       cacheTemplate.put(\"Customer\", template);\n11    }\n12    return template.clone();\n13 }Now, let's see how to make the Customer object cloneable.First the Customer class needs to implement the Cloneable Interface.\nOverride and make the clone() method public, as that is protected in the Object class.\nCall the super.clone()method at the beginning of your clone method.\nOverride the clone() method in all the subclasses of Customer.Code listing 4.15: Customer.java\n\n\n1 public class Customer implements Cloneable {\n2  ...\n3     public Object clone() throws CloneNotSupportedException {\n4        Object obj = super.clone();\n5 \n6        return obj;\n7     }\n8 }In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects. So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't. Also let's say that the Customer object has a reference to an Activity object that contains the customer activities. Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects. The solution:Make the Activity class also cloneable\nMake sure that if the Activity class has other 'changeable' object references, those have to be cloned as well, as seen below\nChange the Customer class clone() method as follows:Code listing 4.16: Customer.java\n\n\n 1 public class Customer implements Cloneable {\n 2   Activity activity;\n 3   ...\n 4     public Customer clone() throws CloneNotSupportedException {\n 5       Customer clonedCustomer = (Customer) super.clone();\n 6 \n 7       // Clone the object referenced objects\n 8       if (activity != null) {\n 9          clonedCustomer.setActivity((Activity) activity.clone());\n10       }\n11       return clonedCustomer;\n12    }\n13 }Note that only mutable objects need to be cloned. References to unchangeable objects such as a String can be used in the cloned object without worry."
}