{
  "title": "Rounding number example[edit]",
  "content": "Sometimes, we are not only interested in mathematically correct rounded numbers, but we want that a fixed number of significant digits are always displayed, regardless of the number used. Here is an example program that returns always the correct string. You are invited to modify it such that it does the same and is simpler!The constant class contains repeating constants that should exist only once in the code so that to avoid inadvertent changes. (If the one constant is changed inadvertently, it is most likely to be seen, as it is used at several locations.)Code listing 3.20: StringUtils.java\n\n\n 1 /**\n 2  * Class that comprises of constant values & string utilities.\n 3  *\n 4  * @since 2013-09-05\n 5  * @version 2014-10-14\n 6  */\n 7 public class StringUtils {\n 8 \t/** Dash or minus constant */\n 9 \tpublic static final char DASH = '-'; \n10 \t/** The exponent sign in a scientific number, or the capital letter E */\n11 \tpublic static final char EXPONENT = 'E';\n12 \t/** The full stop or period */\n13 \tpublic static final char PERIOD = '.';\n14 \t/** The zero string constant used at several places */\n15 \tpublic static final String ZERO = \"0\";\n16 \n17 \t/**\n18 \t * Removes all occurrences of the filter character in the text.\n19 \t *\n20 \t * @param text Text to be filtered\n21 \t * @param filter The character to be removed.\n22 \t * @return the string\n23 \t */\n24 \tpublic static String filter(final String text, final String filter) {\n25 \t\tfinal String[] words = text.split(\"[\" + filter + \"]\");\n26 \n27 \t\tswitch (words.length) {\n28 \t\t\tcase 0: return text;\n29 \t\t\tcase 1: return words[0];\n30 \t\t\tdefault:\n31 \t\t\t\tfinal StringBuilder filteredText = new StringBuilder();\n32 \n33 \t\t\t\tfor (final String word : words) {\n34 \t\t\t\t\tfilteredText.append(word);\n35 \t\t\t\t}\n36 \n37 \t\t\t\treturn filteredText.toString();\n38 \t\t}\n39 \t}\n40 }The MathsUtils class is like an addition to the java.lang.Math class and contains the rounding calculations.Code listing 3.21: MathsUtils.java\n\n\n  1 package string;\n  2 \n  3 /**\n  4  * Class for special mathematical calculations.<br/>\n  5  * ATTENTION:<br/>Should depend only on standard Java libraries!\n  6  *\n  7  * @since 2013-09-05\n  8  * @version 2014-10-14\n  9 */\n 10 public class MathsUtils {\n 11 \n 12 \t// CONSTANTS\n 13 \t// ------------------------------------------\n 14 \n 15 \t/** The exponent sign in a scientific number, or the capital letter E. */\n 16 \tpublic static final char EXPONENT = 'E';\n 17 \n 18 \t/** Value after which the language switches from scientific to double */\n 19 \tprivate static final double E_TO_DOUBLE = 1E-3;\n 20 \n 21 \t/** The zero string constant used at several places. */\n 22 \tpublic static final String ZERO = \"0\";\n 23 \n 24 \t/** The string of zeros */\n 25 \tprivate static final String ZEROS = \"000000000000000000000000000000000\";\n 26 \n 27 \t// METHODS\n 28 \t// ------------------------------------------\n 29 \n 30 \t/**\n 31 \t * Determines, if the number uses a scientific representation.\n 32 \t *\n 33 \t * @param number the number\n 34 \t * @return true, if it is a scientific number, false otherwise\n 35 \t */\n 36 \tprivate static boolean isScientific(final double number) {\n 37 \t\treturn ((new Double(number)).toString().indexOf(EXPONENT) > 0);\n 38 \t}\n 39 \n 40 \t/**\n 41 \t * Determines how many zeros are to be appended after the decimal digits.\n 42 \t *\n 43 \t * @param significantsAfter Requested significant digits after decimal\n 44 \t * @param separator Language-specific decimal separator\n 45 \t * @param number Rounded number\n 46 \t * @return Requested value\n 47 \t */\n 48 \tprivate static byte calculateMissingSignificantZeros(\n 49 \t\t\tfinal byte significantsAfter,\n 50 \t\t\tfinal char separator,\n 51 \t\t\tfinal double number) {\n 52 \n 53 \t\tfinal byte after = findSignificantsAfterDecimal(separator, number);\n 54 \n 55 \t\tfinal byte zeros =\n 56 \t\t\t\t(byte) (significantsAfter - ((after == 0) ? 1 : after));\n 57 \n 58 \t\treturn ((zeros >= 0) ? zeros : 0);\n 59 \t}\n 60 \n 61 \t/**\n 62 \t * Finds the insignificant zeros after the decimal separator.\n 63 \t *\n 64 \t * @param separator Language-specific decimal separator\n 65 \t * @param number the number\n 66 \t * @return the byte\n 67 \t */\n 68 \tprivate static byte findInsignificantZerosAfterDecimal(\n 69 \t\t\tfinal char separator,\n 70 \t\t\tfinal double number) {\n 71 \n 72 \t\tif ((Math.abs(number) >= 1) || isScientific(number)) {\n 73 \t\t\treturn 0;\n 74 \t\t} else {\n 75 \t\t\tfinal StringBuilder string = new StringBuilder();\n 76 \n 77 \t\t\tstring.append(number);\n 78 \t\t\tstring.delete(0,\n 79 \t\t\t\t\tstring.indexOf(new Character(separator).toString()) + 1);\n 80 \n 81 \t\t\t// Determine what to match:\n 82 \t\t\tfinal String regularExpression = \"[1-9]\";\n 83 \n 84 \t\t\tfinal String[] split = string.toString().split(regularExpression);\n 85 \n 86 \t\t\treturn (split.length > 0) ? (byte) split[0].length() : 0;\n 87 \t\t}\n 88 \t}\n 89 \n 90 \t/**\n 91 \t * Calculates the number of all significant digits (without the sign and\n 92 \t * the decimal separator).\n 93 \t *\n 94 \t * @param significantsAfter Requested significant digits after decimal\n 95 \t * @param separator Language-specific decimal separator\n 96 \t * @param number Value where the digits are to be counted\n 97 \t * @return Number of significant digits\n 98 \t */\n 99 \tprivate static byte findSignificantDigits(final byte significantsAfter,\n100 \t\t\tfinal char separator,\n101 \t\t\tfinal double number) {\n102 \n103 \t\tif (number == 0) { return 0; }\n104 \t\telse {\n105 \t\t\tString mantissa =\n106 \t\t\t\t\tfindMantissa(separator, new Double(number).toString());\n107 \n108 \t\t\tif (number == (long)number) {\n109 \t\t\t\tmantissa = mantissa.substring(0, mantissa.length() - 1);\n110 \t\t\t}\n111 \n112 \t\t\tmantissa = retrieveDigits(separator, mantissa);\n113 \t\t\t// Find the position of the first non-zero digit:\n114 \t\t\tshort nonZeroAt = 0;\n115 \n116 \t\t\tfor (; (nonZeroAt < mantissa.length())\n117 \t\t\t\t\t&& (mantissa.charAt(nonZeroAt) == '0'); nonZeroAt++) ;\n118 \n119 \t\t\treturn (byte)mantissa.substring(nonZeroAt).length();\n120 \t\t}\n121 \t}\n122 \t\n123 \t/**\n124 \t * Determines the number of significant digits after the decimal separator\n125 \t * knowing the total number of significant digits and the number before the\n126 \t * decimal separator.\n127 \t *\n128 \t * @param significantsBefore Number of significant digits before separator\n129 \t * @param significantDigits Number of all significant digits\n130 \t * @return Number of significant decimals after the separator\n131 \t */\n132 \tprivate static byte findSignificantsAfterDecimal(\n133 \t\t\tfinal byte significantsBefore,\n134 \t\t\tfinal byte significantDigits) {\n135 \n136 \t\tfinal byte afterDecimal =\n137 \t\t\t\t(byte) (significantDigits - significantsBefore);\n138 \n139 \t\treturn (byte) ((afterDecimal > 0) ? afterDecimal : 0);\n140 \t}\n141 \n142 \t/**\n143 \t * Determines the number of digits before the decimal point.\n144 \t *\n145 \t * @param separator Language-specific decimal separator\n146 \t * @param number Value to be scrutinised\n147 \t * @return Number of digits before the decimal separator\n148 \t */\n149 \tprivate static byte findSignificantsBeforeDecimal(final char separator,\n150 \t\t\t\t\t\t\t\t\t\t\t\t\tfinal double number) {\n151 \n152 \t\tfinal String value = new Double(number).toString();\n153 \n154 \t\t// Return immediately, if result is clear: Special handling at\n155 \t\t// crossroads of floating point and exponential numbers:\n156 \t\tif ((number == 0) || (Math.abs(number) >= E_TO_DOUBLE)\n157 \t\t\t\t&& (Math.abs(number) < 1)) {\n158 \n159 \t\t\treturn 0;\n160 \t\t} else if ((Math.abs(number) > 0) && (Math.abs(number) < E_TO_DOUBLE)) {\n161 \t\t\treturn 1;\n162 \t\t} else {\n163 \t\t\tbyte significants = 0;\n164 \t\t\t// Significant digits to the right of decimal separator:\n165 \t\t\tfor (byte b = 0; b < value.length(); b++) {\n166 \t\t\t\tif (value.charAt(b) == separator) {\n167 \t\t\t\t\tbreak;\n168 \t\t\t\t} else if (value.charAt(b) != StringUtils.DASH) {\n169 \t\t\t\t\tsignificants++;\n170 \t\t\t\t}\n171 \t\t\t}\n172 \n173 \t\t\treturn significants;\n174 \t\t}\n175 \t}\n176 \n177 \t/**\n178 \t * Returns the exponent part of the double number.\n179 \t *\n180 \t * @param number Value of which the exponent is of interest\n181 \t * @return Exponent of the number or zero.\n182 \t */\n183 \tprivate static short findExponent(final double number) {\n184 \t\treturn new Short(findExponent((new Double(number)).toString()));\n185 \t}\n186 \n187 \t/**\n188 \t * Finds the exponent of a number.\n189 \t *\n190 \t * @param value Value where an exponent is to be searched\n191 \t * @return Exponent, if it exists, or \"0\".\n192 \t */\n193 \tprivate static String findExponent(final String value) {\n194 \t\tfinal short exponentAt = (short) value.indexOf(EXPONENT);\n195 \n196 \t\tif (exponentAt < 0) { return ZERO; }\n197 \t\telse {\n198 \t\t\treturn value.substring(exponentAt + 1);\n199 \t\t}\n200 \t}\n201 \n202 \t/**\n203 \t * Finds the mantissa of a number.\n204 \t *\n205 \t * @param separator Language-specific decimal separator\n206 \t * @param value Value where the mantissa is to be found\n207 \t * @return Mantissa of the number\n208 \t */\n209 \tprivate static String findMantissa(final char separator,\n210 \t\t\t\t\t\t\t\t\t\tfinal String value) {\n211 \n212 \t\tString strValue = value;\n213 \n214 \t\tfinal short exponentAt = (short) strValue.indexOf(EXPONENT);\n215 \n216 \t\tif (exponentAt > -1) {\n217 \t\t\tstrValue = strValue.substring(0, exponentAt);\n218 \t\t}\n219 \t\treturn strValue;\n220 \t}\n221 \n222 \t/**\n223 \t * Retrieves the digits of the value without decimal separator or sign.\n224 \t *\n225 \t * @param separator\n226 \t * @param number Mantissa to be scrutinised\n227 \t * @return The digits only\n228 \t */\n229 \tprivate static String retrieveDigits(final char separator, String number) {\n230 \t\t// Strip off exponent part, if it exists:\n231 \t\tshort eAt = (short)number.indexOf(EXPONENT);\n232 \n233 \t\tif (eAt > -1) {\n234 \t\t\tnumber = number.substring(0, eAt);\n235 \t\t}\n236 \n237 \t\treturn number.replace((new Character(StringUtils.DASH)).toString(), \"\").\n238 \t\t\t\treplace((new Character(separator)).toString(), \"\");\n239 \t}\n240 \n241 \n242 \t// ---- Public methods ----------------------\n243 \n244 \t/**\n245 \t * Returns the number of digits in the long value.\n246 \t *\n247 \t * @param value the value\n248 \t * @return the byte\n249 \t */\n250 \tpublic static byte digits(final long value) {\n251 \t\treturn (byte) StringUtils.filter(Long.toString(value), \".,\").length();\n252 \t}\n253 \n254 \t/**\n255 \t * Finds the significant digits after the decimal separator of a mantissa.\n256 \t *\n257 \t * @param separator Language-specific decimal separator\n258 \t * @param number Value to be scrutinised\n259 \t * @return Number of significant zeros after decimal separator.\n260 \t */\n261 \tpublic static byte findSignificantsAfterDecimal(final char separator,\n262 \t\t\t\t\t\t\t\t\t\t\t\t\tfinal double number) {\n263 \n264 \t\tif (number == 0) { return 1; }\n265 \t\telse {\n266 \t\t\tString value = (new Double(number)).toString();\n267 \n268 \t\t\tfinal short separatorAt = (short) value.indexOf(separator);\n269 \n270 \t\t\tif (separatorAt > -1) {\n271 \t\t\t\tvalue = value.substring(separatorAt + 1);\n272 \t\t\t}\n273 \n274 \t\t\tfinal short exponentAt = (short) value.indexOf(EXPONENT);\n275 \n276 \t\t\tif (exponentAt > 0) {\n277 \t\t\t\tvalue = value.substring(0, exponentAt);\n278 \t\t\t}\n279 \n280 \t\t\tfinal Long longValue = new Long(value).longValue();\n281 \n282 \t\t\tif (Math.abs(number) < 1) {\n283 \t\t\t\treturn (byte) longValue.toString().length();\n284 \t\t\t} else if (longValue == 0) {\n285 \t\t\t\treturn 0;\n286 \t\t\t} else {\n287 \t\t\t\treturn (byte) ((\"0.\" + value).length() - 2);\n288 \t\t\t}\n289 \t\t}\n290 \t}\n291 \n292 \t/**\n293 \t * Calculates the power of the base to the exponent without changing the\n294 \t * least-significant digits of a number.\n295 \t *\n296 \t * @param basis\n297 \t * @param exponent\n298 \t * @return basis to power of exponent\n299 \t */\n300 \tpublic static double power(final int basis, final short exponent) {\n301 \t\treturn power((short) basis, exponent);\n302 \t}\n303 \n304 \t/**\n305 \t * Calculates the power of the base to the exponent without changing the\n306 \t * least-significant digits of a number.\n307 \t *\n308 \t * @param basis the basis\n309 \t * @param exponent the exponent\n310 \t * @return basis to power of exponent\n311 \t */\n312 \tpublic static double power(final short basis, final short exponent) {\n313 \t\tif (basis == 0) {\n314 \t\t\treturn (exponent != 0) ? 1 : 0;\n315 \t\t} else {\n316 \t\t\tif (exponent == 0) {\n317 \t\t\t\treturn 1;\n318 \t\t\t} else {\n319 \t\t\t\t// The Math method power does change the least significant\n320 \t\t\t\t// digits after the decimal separator and is therefore useless.\n321 \t\t\t\tdouble result = 1;\n322 \t\t\t\tshort s = 0;\n323 \n324 \t\t\t\tif (exponent > 0) {\n325 \t\t\t\t\tfor (; s < exponent; s++) {\n326 \t\t\t\t\t\tresult *= basis;\n327 \t\t\t\t\t}\n328 \t\t\t\t} else if (exponent < 0) {\n329 \t\t\t\t\tfor (s = exponent; s < 0; s++) {\n330 \t\t\t\t\t\tresult /= basis;\n331 \t\t\t\t\t}\n332 \t\t\t\t}\n333 \n334 \t\t\t\treturn result;\n335 \t\t\t}\n336 \t\t}\n337 \t}\n338 \n339 \t/**\n340 \t * Rounds a number to the decimal places.\n341 \t *\n342 \t * @param significantsAfter Requested significant digits after decimal\n343 \t * @param separator Language-specific decimal separator\n344 \t * @param number Number to be rounded\n345 \t * @return Rounded number to the requested decimal places\n346 \t */\n347 \tpublic static double round(final byte significantsAfter,\n348 \t\t\t\t\t\t\t\tfinal char separator,\n349 \t\t\t\t\t\t\t\tfinal double number) {\n350 \n351 \t\tif (number == 0) { return 0; }\n352 \t\telse {\n353 \t\t\tfinal double constant = power(10, (short)\n354 \t\t\t\t\t(findInsignificantZerosAfterDecimal(separator, number)\n355 \t\t\t\t\t\t\t+ significantsAfter));\n356 \t\t\tfinal short dExponent = findExponent(number);\n357 \n358 \t\t\tshort exponent = dExponent;\n359 \n360 \t\t\tdouble value = number*constant*Math.pow(10, -exponent);\n361 \t\t\tfinal String exponentSign =\n362 \t\t\t\t\t(exponent < 0) ? String.valueOf(StringUtils.DASH) : \"\";\n363 \n364 \t\t\tif (exponent != 0) {\n365 \t\t\t\texponent = (short) Math.abs(exponent);\n366 \n367 \t\t\t\tvalue = round(value);\n368 \t\t\t} else {\n369 \t\t\t\tvalue = round(value)/constant;\n370 \t\t\t}\n371 \n372 \t\t\t// Power method cannot be used, as the exponentiated number may\n373 \t\t\t// exceed the maximal long value.\n374 \t\t\texponent -= Math.signum(dExponent)*(findSignificantDigits\n375 \t\t\t\t\t(significantsAfter, separator, value) - 1);\n376 \n377 \t\t\tif (dExponent != 0) {\n378 \t\t\t\tString strValue = Double.toString(value);\n379 \n380 \t\t\t\tstrValue = strValue.substring(0, strValue.indexOf(separator))\n381 \t\t\t\t\t\t+ EXPONENT + exponentSign + Short.toString(exponent);\n382 \n383 \t\t\t\tvalue = new Double(strValue);\n384 \t\t\t}\n385 \n386 \t\t\treturn value;\n387 \t\t}\n388 \t}\n389 \n390 \t/**\n391 \t * Rounds a number according to mathematical rules.\n392 \t *\n393 \t * @param value the value\n394 \t * @return the double\n395 \t */\n396 \tpublic static double round(final double value) {\n397 \t\treturn (long) (value + .5);\n398 \t}\n399 \n400 \t/**\n401 \t * Rounds to a fixed number of significant digits.\n402 \t *\n403 \t * @param significantDigits Requested number of significant digits\n404 \t * @param separator Language-specific decimal separator\n405 \t * @param dNumber Number to be rounded\n406 \t * @return Rounded number\n407 \t */\n408 \tpublic static String roundToString(final byte significantDigits,\n409 \t\t\t\t\t\t\t\t\t\tfinal char separator,\n410 \t\t\t\t\t\t\t\t\t\tdouble dNumber) {\n411 \t\t\t\t\t\t\t\t\t\t\n412 \t\t// Number of significants that *are* before the decimal separator:\n413 \t\tfinal byte significantsBefore =\n414 \t\t\tfindSignificantsBeforeDecimal(separator, dNumber);\n415 \t\t// Number of decimals that *should* be after the decimal separator:\n416 \t\tfinal byte significantsAfter = findSignificantsAfterDecimal(\n417 \t\t\t\tsignificantsBefore, significantDigits);\n418 \t\t// Round to the specified number of digits after decimal separator:\n419 \t\tfinal double rounded = MathsUtils.round(significantsAfter, separator, dNumber);\n420 \n421 \t\tfinal String exponent = findExponent((new Double(rounded)).toString());\n422 \t\tfinal String mantissa = findMantissa(separator,\n423 \t\t\t\t\t\t(new Double(rounded)).toString());\n424 \n425 \t\tfinal double dMantissa = new Double(mantissa).doubleValue();\n426 \t\tfinal StringBuilder result = new StringBuilder(mantissa);\n427 \t\t// Determine the significant digits in this number:\n428 \t\tfinal byte significants = findSignificantDigits(significantsAfter,\n429 \t\t\t\tseparator, dMantissa);\n430 \t\t// Add lagging zeros, if necessary:\n431 \t\tif (significants <= significantDigits) {\n432 \t\t\tif (significantsAfter != 0) {\n433 \t\t\t\tresult.append(ZEROS.substring(0,\n434 \t\t\t\t\t\tcalculateMissingSignificantZeros(significantsAfter,\n435 \t\t\t\t\t\t\t\tseparator, dMantissa)));\n436 \t\t\t} else {\n437 \t\t\t\t// Cut off the decimal separator & after decimal digits:\n438 \t\t\t\tfinal short decimal = (short) result.indexOf(\n439 \t\t\t\t\t\tnew Character(separator).toString());\n440 \n441 \t\t\t\tif (decimal > -1) {\n442 \t\t\t\t\tresult.setLength(decimal);\n443 \t\t\t\t}\n444 \t\t\t}\n445 \t\t} else if (significantsBefore > significantDigits) {\n446 \t\t\tdNumber /= power(10, (short) (significantsBefore - significantDigits));\n447 \n448 \t\t\tdNumber = round(dNumber);\n449 \n450 \t\t\tfinal short digits =\n451 \t\t\t\t\t(short) (significantDigits + ((dNumber < 0) ? 1 : 0));\n452 \n453 \t\t\tfinal String strDouble = (new Double(dNumber)).toString().substring(0, digits);\n454 \n455 \t\t\tresult.setLength(0);\n456 \t\t\tresult.append(strDouble + ZEROS.substring(0,\n457 \t\t\t\t\tsignificantsBefore - significantDigits));\n458 \t\t}\n459 \n460 \t\tif (new Short(exponent) != 0) {\n461 \t\t\tresult.append(EXPONENT + exponent);\n462 \t\t}\n463 \n464 \t\treturn result.toString();\n465 \t} // public static String roundToString()\n466 \n467 \t/**\n468 \t * Rounds to a fixed number of significant digits.\n469 \t *\n470 \t * @param separator Language-specific decimal separator\n471 \t * @param significantDigits Requested number of significant digits\n472 \t * @param value Number to be rounded\n473 \t * @return Rounded number\n474 \t */\n475 \tpublic static String roundToString(final char separator,\n476 \t\t\t\t\t\t\t\t\t\tfinal int significantDigits,\n477 \t\t\t\t\t\t\t\t\t\tfloat value) {\n478 \n479 \t\treturn roundToString((byte)significantDigits, separator,\n480 \t\t\t\t(double)value);\n481 \t}\n482 } // class MathsUtilsThe code is tested with the following JUnit test:Code listing 3.22: MathsUtilsTest.java\n\n\n  1 package string;\n  2 \n  3 import static org.junit.Assert.assertEquals;\n  4 import static org.junit.Assert.assertFalse;\n  5 import static org.junit.Assert.assertTrue;\n  6 \n  7 import java.util.Vector;\n  8 \n  9 import org.junit.Test;\n 10 \n 11 /**\n 12  * The JUnit test for the <code>MathsUtils</code> class.\n 13  *\n 14  * @since 2013-03-26\n 15  * @version 2014-10-14\n 16  */\n 17 public class MathsUtilsTest {\n 18 \n 19 \t/**\n 20 \t * Method that adds a negative and a positive value to values.\n 21 \t *\n 22 \t * @param d the double value\n 23 \t * @param values the values\n 24 \t */\n 25 \tprivate static void addValue(final double d, Vector<Double> values) {\n 26 \t\tvalues.add(-d);\n 27 \t\tvalues.add(d);\n 28 \t}\n 29 \n 30 \t// Public methods ------\n 31 \n 32 \t/**\n 33 \t * Tests the round method with a double parameter.\n 34 \t */\n 35 \t@Test\n 36 \tpublic void testRoundToStringDoubleByteCharDouble() {\n 37 \t\t// Test rounding\n 38 \t\tfinal Vector<Double> values = new Vector<Double>();\n 39 \t\tfinal Vector<String> strValues = new Vector<String>();\n 40 \n 41 \t\tvalues.add(0.0);\n 42 \t\tstrValues.add(\"0.00000\");\n 43 \t\taddValue(1.4012984643248202e-45, values);\n 44 \t\tstrValues.add(\"-1.4012E-45\");\n 45 \t\tstrValues.add(\"1.4013E-45\");\n 46 \t\taddValue(1.999999757e-5, values);\n 47 \t\tstrValues.add(\"-1.9999E-5\");\n 48 \t\tstrValues.add(\"2.0000E-5\");\n 49 \t\taddValue(1.999999757e-4, values);\n 50 \t\tstrValues.add(\"-1.9999E-4\");\n 51 \t\tstrValues.add(\"2.0000E-4\");\n 52 \t\taddValue(1.999999757e-3, values);\n 53 \t\tstrValues.add(\"-0.0019999\");\n 54 \t\tstrValues.add(\"0.0020000\");\n 55 \t\taddValue(0.000640589, values);\n 56 \t\tstrValues.add(\"-6.4058E-4\");\n 57 \t\tstrValues.add(\"6.4059E-4\");\n 58 \t\taddValue(0.3396899998188019, values);\n 59 \t\tstrValues.add(\"-0.33968\");\n 60 \t\tstrValues.add(\"0.33969\");\n 61 \t\taddValue(0.34, values);\n 62 \t\tstrValues.add(\"-0.33999\");\n 63 \t\tstrValues.add(\"0.34000\");\n 64 \t\taddValue(7.07, values);\n 65 \t\tstrValues.add(\"-7.0699\");\n 66 \t\tstrValues.add(\"7.0700\");\n 67 \t\taddValue(118.188, values);\n 68 \t\tstrValues.add(\"-118.18\");\n 69 \t\tstrValues.add(\"118.19\");\n 70 \t\taddValue(118.2, values);\n 71 \t\tstrValues.add(\"-118.19\");\n 72 \t\tstrValues.add(\"118.20\");\n 73 \t\taddValue(123.405009, values);\n 74 \t\tstrValues.add(\"-123.40\");\n 75 \t\tstrValues.add(\"123.41\");\n 76 \t\taddValue(30.76994323730469, values);\n 77 \t\tstrValues.add(\"-30.769\");\n 78 \t\tstrValues.add(\"30.770\");\n 79 \t\taddValue(130.76994323730469, values);\n 80 \t\tstrValues.add(\"-130.76\");\n 81 \t\tstrValues.add(\"130.77\");\n 82 \t\taddValue(540, values);\n 83 \t\tstrValues.add(\"-539.99\");\n 84 \t\tstrValues.add(\"540.00\");\n 85 \t\taddValue(12345, values);\n 86 \t\tstrValues.add(\"-12344\");\n 87 \t\tstrValues.add(\"12345\");\n 88 \t\taddValue(123456, values);\n 89 \t\tstrValues.add(\"-123450\");\n 90 \t\tstrValues.add(\"123460\");\n 91 \t\taddValue(540911, values);\n 92 \t\tstrValues.add(\"-540900\");\n 93 \t\tstrValues.add(\"540910\");\n 94 \t\taddValue(9.223372036854776e56, values);\n 95 \t\tstrValues.add(\"-9.2233E56\");\n 96 \t\tstrValues.add(\"9.2234E56\");\n 97 \n 98 \t\tbyte i = 0;\n 99 \t\tfinal byte significants = 5;\n100 \n101 \t\tfor (final double element : values) {\n102 \t\t\tfinal String strValue;\n103 \n104 \t\t\ttry {\n105 \t\t\t\tstrValue = MathsUtils.roundToString(significants, StringUtils.PERIOD, element);\n106 \n107 \t\t\t\tSystem.out.println(\" MathsUtils.round(\" + significants  + \", '\"\n108 \t\t\t\t\t\t+ StringUtils.PERIOD + \"', \" + element + \") ==> \"\n109 \t\t\t\t\t\t+ strValue + \" = \" + strValues.get(i));\n110 \t\t\t\tassertEquals(\"Testing roundToString\", strValue, strValues.get(i++));\n111 \t\t\t} catch (final Exception e) {\n112 \t\t\t\t// TODO Auto-generated catch block\n113 \t\t\t\te.printStackTrace();\n114 \t\t\t}\n115 \t\t}\n116 \t}\n117 \n118 }\t// class MathsUtilsTestThe output of the JUnit test follows:Output for code listing 3.22\n\n MathsUtils.round(5, '.', 0.0) ==> 0.00000 = 0.00000\n MathsUtils.round(5, '.', -1.4012984643248202E-45) ==> -1.4012E-45 = -1.4012E-45\n MathsUtils.round(5, '.', 1.4012984643248202E-45) ==> 1.4013E-45 = 1.4013E-45\n MathsUtils.round(5, '.', -1.999999757E-5) ==> -1.9999E-5 = -1.9999E-5\n MathsUtils.round(5, '.', 1.999999757E-5) ==> 2.0000E-5 = 2.0000E-5\n MathsUtils.round(5, '.', -1.999999757E-4) ==> -1.9999E-4 = -1.9999E-4\n MathsUtils.round(5, '.', 1.999999757E-4) ==> 2.0000E-4 = 2.0000E-4\n MathsUtils.round(5, '.', -0.001999999757) ==> -0.0019999 = -0.0019999\n MathsUtils.round(5, '.', 0.001999999757) ==> 0.0020000 = 0.0020000\n MathsUtils.round(5, '.', -6.40589E-4) ==> -6.4058E-4 = -6.4058E-4\n MathsUtils.round(5, '.', 6.40589E-4) ==> 6.4059E-4 = 6.4059E-4\n MathsUtils.round(5, '.', -0.3396899998188019) ==> -0.33968 = -0.33968\n MathsUtils.round(5, '.', 0.3396899998188019) ==> 0.33969 = 0.33969\n MathsUtils.round(5, '.', -0.34) ==> -0.33999 = -0.33999\n MathsUtils.round(5, '.', 0.34) ==> 0.34000 = 0.34000\n MathsUtils.round(5, '.', -7.07) ==> -7.0699 = -7.0699\n MathsUtils.round(5, '.', 7.07) ==> 7.0700 = 7.0700\n MathsUtils.round(5, '.', -118.188) ==> -118.18 = -118.18\n MathsUtils.round(5, '.', 118.188) ==> 118.19 = 118.19\n MathsUtils.round(5, '.', -118.2) ==> -118.19 = -118.19\n MathsUtils.round(5, '.', 118.2) ==> 118.20 = 118.20\n MathsUtils.round(5, '.', -123.405009) ==> -123.40 = -123.40\n MathsUtils.round(5, '.', 123.405009) ==> 123.41 = 123.41\n MathsUtils.round(5, '.', -30.76994323730469) ==> -30.769 = -30.769\n MathsUtils.round(5, '.', 30.76994323730469) ==> 30.770 = 30.770\n MathsUtils.round(5, '.', -130.7699432373047) ==> -130.76 = -130.76\n MathsUtils.round(5, '.', 130.7699432373047) ==> 130.77 = 130.77\n MathsUtils.round(5, '.', -540.0) ==> -539.99 = -539.99\n MathsUtils.round(5, '.', 540.0) ==> 540.00 = 540.00\n MathsUtils.round(5, '.', -12345.0) ==> -12344 = -12344\n MathsUtils.round(5, '.', 12345.0) ==> 12345 = 12345\n MathsUtils.round(5, '.', -123456.0) ==> -123450 = -123450\n MathsUtils.round(5, '.', 123456.0) ==> 123460 = 123460\n MathsUtils.round(5, '.', -540911.0) ==> -540900 = -540900\n MathsUtils.round(5, '.', 540911.0) ==> 540910 = 540910\n MathsUtils.round(5, '.', -9.223372036854776E56) ==> -9.2233E56 = -9.2233E56\n MathsUtils.round(5, '.', 9.223372036854776E56) ==> 9.2234E56 = 9.2234E56If you are interested in a comparison with C#, take a look at the rounding number example there. If you are interested in a comparison with C++, you can compare this code here with the same example over there.Notice that in the expression starting with if ((D == 0), I have to use OR instead of the || because of a bug in the source template."
}