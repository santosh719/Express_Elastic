{
  "title": "Layout[edit]",
  "content": "Layouts are what make applets visible. Without a layout, nothing would display. There are five different types of layouts to choose from  some are very simple while others are complex.Flow Layout[edit]This layout places components left to right, using as much space as is needed. The Flow Layout is the default layout for applets and, therefore, does not need to be set. However, for clarity, one can specify the applet layout as a Flow Layout by placing this line of code at the top of the init() method:Code section 9.16: Flow Layout\n\n\n1 setLayout(new FlowLayout());The added components to the layout that follow will be placed on screen in order of which they are added.Code section 9.17: Component display\n\n\n1 public void init() {\n2     setLayout(new FlowLayout());\n3     add(nameLabel);\n4     add(t1);\n5     add(submitButton);\n6 }Assuming that these variables are defined the same as above, these lines of code will create the layout of an applet that is composed of a label, a text field, and a button. They will all appear on one line if the window permits. By changing the width of window, the Flow Layout will contract and expand the components accordingly.Grid Layout[edit]This layout arranges components in the form of the table (grid). The number of rows and columns in the grid is specified in the constructor. The other two parameters, if present, specify vertical and horizontal padding between components.Code listing 9.4: GridLayoutApplet.java\n\n\n 1 import java.applet.Applet;\n 2 import java.awt.Button;\n 3 import java.awt.GridLayout;\n 4 import java.awt.Label;\n 5 import java.awt.TextField;\n 6 \n 7 public class GridLayoutApplet extends Applet {\n 8 \n 9     Button submitButton = new Button(\"Submit\");\n10     TextField t1 = new TextField();                // Blank\n11     TextField t2 = new TextField(5);               // Blank in 5 columns\n12     TextField t3 = new TextField(\"Input here\");    // Predefined text\n13     TextField t4 = new TextField(\"Input here\", 5); // Predefined text in 5 columns\n14     Label nameLabel = new Label(\"Name: \");\n15 \n16     /**\n17      * Init.\n18      */\n19     public void init() {\n20         // 3 rows, 4 columns, 2 pixel spacing\n21         setLayout(new GridLayout(3, 4, 2, 2));\n22         add(nameLabel);\n23         add(t1);\n24         add(t2);\n25         add(t3);\n26         add(t4);\n27         add(submitButton);\n28     }\n29 }The items have been displayed in this order:1st\n2nd\n\n\n\n\n3th\n4th\n\n\n\n\n5th\n6thWe see that the layout has been configured to fill the grid left-to-right and then top-to-bottom and that the two last columns have been ignored (they don't even exist). They have been ignored because there are not enough items to fill them and the number of rows is prior to the number of columns. This means that when you specify a number of rows that is not zero, the number of columns is simply ignored. You should specify zero rows in order that the number of columns is taken into account.A grid layout creates cells with equal sizes. So it can be used not only to display items as a grid but also to display two items with the same width or height.Border Layout[edit]This layout places one big component in the center and up till four components at the edges. When adding to the container with this layout, you need to specify the location as the second parameter like BorderLayout.CENTER for the center or one of the world directions for the edge (BorderLayout.NORTH points to the top edge).Code section 9.19: Border layout\n\n\n1 import java.awt.*;\n2 \n3 Container container = getContentPane();\n4 container.setLayout(new BorderLayout());\n5 \n6 JButton b2 = new JButton(\"two\");\n7 // Add the button to the right edge.\n8 container.add(b2, BorderLayout.EAST);\n9 ...If you have two components, it is not the same to put the first in the north and the second to the center as to put the first in the center and the second to the south. In the first case, the layout will calculate the size of the component and the second component will have all the space left. In the second case, it is the opposite.Card Layout[edit]A card stackThe card layout displays only one item at a time and is only interesting with interactivity. The other items are stored in a stack and the displayed item is one of the items of the stack. The name of the card layout is a reference to a playing card deck where you can see the card at the top of the stack and you can put a card on the top. The difference in the card layout is that the items in the stack keeps their order. When you use this layout, you must use this method to add items to the container, i.e. the applet:void add(String itemId, Component item)\nAdds an item to the container and associate the item to the id.The card layout has several methods to change the currently displayed item:void first(Container container)\nDisplay the first item of the stack.\n\n\nvoid next(Container container)\nDisplay the item of the stack that is located after the displayed item.\n\n\nvoid previous(Container container)\nDisplay the item of the stack that is located before the displayed item.\n\n\nvoid last(Container container)\nDisplay the last item of the stack.\n\n\nvoid show(Container container, String itemId)\nDisplay an item by its id.Code listing 9.5: CardLayoutApplet.java\n\n\n 1 import java.applet.Applet;\n 2 import java.awt.CardLayout;\n 3 import java.awt.Label;\n 4 \n 5 public class CardLayoutApplet extends Applet {\n 6 \n 7     static final String COMPONENT_POSITION_TOP = \"TOP\";\n 8     static final String COMPONENT_POSITION_MIDDLE = \"MIDDLE\";\n 9     static final String COMPONENT_POSITION_BOTTOM = \"BOTTOM\";\n10 \n11     Label topLabel = new Label(\"At the top\");\n12     Label middleLabel = new Label(\"In the middle\");\n13     Label bottomLabel = new Label(\"At the bottom\");\n14 \n15     /**\n16      * Init.\n17      */\n18     public void init() {\n19         setLayout(new CardLayout());\n20         add(COMPONENT_POSITION_TOP, topLabel);\n21         add(COMPONENT_POSITION_MIDDLE, middleLabel);\n22         add(COMPONENT_POSITION_BOTTOM, bottomLabel);\n23         ((CardLayout)getLayout()).show(this, COMPONENT_POSITION_MIDDLE);\n24     }\n25 }"
}