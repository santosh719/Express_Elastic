{
  "title": "Generics",
  "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n GenericsJava is a strongly typed language, so a field in a class may be typed like this:Code listing 4.34: Repository.java\n\n\n 1 public class Repository {\n 2 \n 3    public Integer item;\n 4 \n 5    public Integer getItem() {\n 6       return item;\n 7    }\n 8 \n 9    public void setItem(Integer newItem) {\n10       item = newItem;\n11    }\n12 }This ensures that, only Integer objects can be put in the field and a ClassCastException can't occur at runtime, only compile-time error can occur. Unfortunately, it can be used only with Integer objects. If you want to use the same class in another context with Strings, you have to generalize the type like this:Code listing 4.35: Repository.java\n\n\n 1 public class Repository {\n 2 \n 3    public Object item;\n 4 \n 5    public Object getItem() {\n 6       return item;\n 7    }\n 8 \n 9    public void setItem(Integer newItem) {\n10       item = newItem;\n11    }\n12 \n13    public void setItem(String newItem) {\n14       item = newItem;\n15    }\n16 }But you will have ClassCastException at runtime again and you can't easily use your field. The solution is to use Generics."
}