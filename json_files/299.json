{
  "title": "Threads[edit]",
  "content": "In light of the above discussion, a thread is the smallest unit of processing that can be scheduled by an operating system. Therefore, using threads, a programmer can effectively create two or more tasks[1] that run at the same time. The first call-to-action is to implement a set of tasks that a particular thread would execute. To do so, we require the creation of a Runnable process.Creating a Runnable process block[edit]A Runnable process block is a simple class that implements a run() method. Within the run() method is the actual task that needs to be executed by a running thread. By implementing a class with the Runnable interface, we ensure that the class holds a run() method. Consider the following program:Code listing 1: A runnable process\n\n\nimport java.util.Random;\npublic class RunnableProcess implements Runnable {\n    private String name;\n    private int time;\n    private Random rand = new Random();\n\n    public RunnableProcess(String name) {\n        this.name = name;\n        this.time = rand.nextInt(999);\n    }\n\n    public void run() {\n        try {\n            System.out.printf(\"%s is sleeping for %d \\n\", this.name, this.time);\n            Thread.sleep(this.time);\n            System.out.printf(\"%s is done.\\n\", this.name);\n        } catch(Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}In the above code, we create a class called RunnableProcess and implement the Runnable interface to ensure that we have a run() method in the class declaration.Code section 1.1: Implementing the Runnable interface\n\n\npublic class RunnableProcess implements Runnable {\n    ...\n    public void run() {\n        ...\n    }\n}We then declare the rest of the logic for the class. For the constructor, we take a String parameter that would serve as the name of the class. Then, we initialize the class member variable time with a random number between 0 and 999. To ensure the initialization of a random number, we use the Random class in the java.util package.Code section 1.2: Including ability to generate random integers between 0 and 999\n\n\nimport java.util.Random;\n...\nprivate Random rand = new Random();\n...\nthis.time = rand.nextInt(999);The actual task that would be executed per this runnable block is presented within the run() method. To keep safe from exceptions occurring because of the concurrent programming, we wrap the code within this method with a try..catch block. The executing task actually consists of just three statements. The first outputs the provided name for the Runnable process, and the last reports that the thread has executed. Perhaps the most intriguing part of the code is the second statement: Thread.sleep(...).Code section 1.3: The actual runnable process task\n\n\n...\nSystem.out.printf(\"%s is sleeping for %d \\n\", this.name, this.time);\nThread.sleep(this.time);\nSystem.out.printf(\"%s is done \\n\", this.name);\n...This statement allows the thread executing the current runnable block to halt its execution for the given amount of time. This time is presented in milliseconds. But for our convenience, this time would be the random number generated in the constructor and can be anywhere between 0 and 999 milliseconds. We will explore this in a later section. Creating a Runnable process block is just the beginning. No code is actually executed. To do so, we would require the creation of threads that would then individually execute this task.Creating threads[edit]Once we have a Runnable process block, we can create various threads that can then execute the logic encased within such blocks. Multithreading capabilities in Java are utilized and manipulated using the Thread class. A Thread object therefore holds all the necessary logic and devices to create truly multithreaded programs. Consider the following program:Code listing 2: Creating Thread objects\n\n\npublic class ThreadLogic {\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new RunnableProcess(\"Thread-1\"));\n        Thread t2 = new Thread(new RunnableProcess(\"Thread-2\"));\n        Thread t3 = new Thread(new RunnableProcess(\"Thread-3\"));\n    }\n}Creating threads is as simple as the above program suggests. You just have to create an object of the Thread class and pass a reference to a Runnable process object. In the case above, we present the Thread constructor with the class object for the RunnableProcess class that we created in code listing 1. But for each object, we give a different name (i.e., \"Thread-1\" and \"Thread-2\", etc.) to differentiate between the three Thread objects. The above example only declares Thread objects and hasn't yet started them for execution.Starting threads[edit]Now, that we know how to effectively create a Runnable process block and a Thread object that executes it, we need to understand how to start the created Thread objects. This couldn't be simpler. For this process, we will be calling the start() method on the Thread objects and voil, our threads will begin executing their individual process tasks.Code listing 3: Starting the Thread objects\n\n\npublic class ThreadLogic {\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new RunnableProcess(\"Thread-1\"));\n        Thread t2 = new Thread(new RunnableProcess(\"Thread-2\"));\n        Thread t3 = new Thread(new RunnableProcess(\"Thread-3\"));\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}The above code will start all three declared threads. This way, all three threads will begin their execution one-by-one. However, this being concurrent programming and us having declared random times for the halting of the execution, the outputs for every one of us would differ. Following is the output we received when we executed the above program.Output for code listing 3\n\nThread-1 is sleeping for 419\nThread-3 is sleeping for 876\nThread-2 is sleeping for 189\nThread-2 is done\nThread-1 is done\nThread-3 is doneIt should be noted that the execution of the Thread didn't occur in the desired order. Instead of the order t1t2t3, the threads executed in the order of t1t3t2. The order in which the threads are executed is completely dependent on the operating system and may change for every execution of the program, thus making output of multithreaded application difficult to predict and control. Some people suggest that this is the major reason that adds to the complexity of multithreaded programming and its debugging. However, it should be observed that once the threads were put to sleep using the Thread.sleep(...) function, the execution intervals and order can be predicted quite capably. The thread with the least amount of sleeping time was t2 (\"Thread-2\") with 189 milliseconds of sleep hence it got called first. Then t1 was called and finally t3 was called."
}