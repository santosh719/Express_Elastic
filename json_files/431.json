{
  "title": "Invoking C",
  "content": "Navigate Advanced topic: (vde)\n\n Networking\n Database programming\n Regular Expressions\n Libraries, extensions and frameworks\n 3D programming\n Java Native Interface\n Invoking C\n Byte CodeYou can use Runtime.exec() method to invoke a program from within a running Java application. Runtime.exec() also allows you to perform operations related to the program, such as control the program's standard input and output, wait until it completes execution, and get its exit status.Here's a simple C application that illustrates these features. This C program will be called from Java:#include <stdio.h>\n\nint main() {\n    printf(\"testing\\n\");\n    return 0;\n}This application writes a string \"testing\" to standard output, and then terminates with an exit status of 0. To execute this simple program within a Java application, compile the C application:Compilation\n\n$ cc test.c -o testThen invoke the C program using this Java code:Code listing 10.2: Invoking C programs.\n\n\n 1 import java.io.InputStream;\n 2 import java.io.BufferedReader;\n 3 import java.io.InputStreamReader;\n 4 import java.io.IOException;\n 5 import java.io.InterruptedException;\n 6 import java.io.Process;\n 7 import java.io.Runtime;\n 8 \n 9 import java.util.ArrayList;\n10 \n11 public class ExecDemo {\n12     public static String[] runCommand(String cmd) throws IOException {\n13         // --- set up list to capture command output lines ---\n14         ArrayList list = new ArrayList();\n15 \n16         // --- start command running\n17         Process proc = Runtime.getRuntime().exec(cmd);\n18 \n19         // --- get command's output stream and\n20         // put a buffered reader input stream on it ---\n21         InputStream istr = proc.getInputStream();\n22         BufferedReader br = new BufferedReader(new InputStreamReader(istr));\n23 \n24         // --- read output lines from command\n25         String str;\n26         while ((str = br.readLine()) != null) {\n27             list.add(str);\n28         }\n29 \n30         // wait for command to terminate\n31         try {\n32             proc.waitFor();\n33         }\n34         catch (InterruptedException e) {\n35             System.err.println(\"process was interrupted\");\n36         }\n37 \n38         // check its exit value\n39         if (proc.exitValue() != 0) {\n40             System.err.println(\"exit value was non-zero\");\n41         }\n42 \n43         // close stream\n44         br.close();\n45 \n46         // return list of strings to caller\n47         return (String[])list.toArray(new String[0]);\n48     }\n49 \n50     public static void main(String args[]) throws IOException {\n51         try {\n52 \n53             // run a command\n54             String outlist[] = runCommand(\"test\");\n55 \n56             // display its output\n57             for (int i = 0; i < outlist.length; i++)\n58                 System.out.println(outlist[i]);\n59         }\n60         catch (IOException e) {\n61             System.err.println(e);\n62         }\n63     }\n64 }The demo calls a method runCommand to actually run the program.Code section 10.1: Running a command.\n\n\n1 String outlist[] = runCommand(\"test\");This method hooks an input stream to the program's output stream, so that it can read the program's output, and save it into a list of strings.Code section 10.2: Reading the program's output.\n\n\n1 InputStream istr = proc.getInputStream();\n2 BufferedReader br = new BufferedReader(new InputStreamReader(istr));\n3              \n4 String str;\n5 while ((str = br.readLine()) != null) {\n6     list.add(str);\n7 }"
}