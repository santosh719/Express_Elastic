{
  "title": "Introspection[edit]",
  "content": "In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.For example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field \"name\" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple \"is-a\" relationship can be confusing, as can looking through dozens of class definitions to find where a single \"dumb\" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.Code listing 9.13: Get property from a JavaBean\n\n\n 1 public static Object getProperty(Object o, String propertyName) {\n 2    if (o == null ||\n 3        propertyName == null ||\n 4        propertyName.length() < 1) {\n 5       return null;\n 6    }\n 7    // Based on the property name build the getter method name\n 8    String methodName = \"get\" +\n 9                       propertyName.substring(0,1).toUpperCase() +\n10                       propertyName.substring(1);\n11    Object property = null;\n12    try {\n13       java.lang.Class c = o.getClass();\n14       java.lang.reflect.Method m = c.getMethod(methodName, null);\n15       property = m.invoke(o, null);\n16    } catch (NoSuchMethodException e) {\n17      // Handle exception\n18    }  catch (SecurityException e) {\n19      // No permission; Handle exception\n20    }\n21 return property;\n22 }orCode listing 9.14: Use Apache Commons BeanUtils\n\n\n 1 import org.apache.commons.beanutils.PropertyUtils;\n 2 \n 3 try {\n 4   Object myValue = PropertyUtils.getSimpleProperty(o, propertyName);\n 5 } catch (IllegalAccessException e) {\n 6   // Handle exception\n 7 } catch (InvocationTargetException e) {\n 8   // Handle exception\n 9 } catch (NoSuchMethodException e) {\n10   // Handle exception\n11 }"
}