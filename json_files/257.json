{
  "title": "Collection classes[edit]",
  "content": "There is no direct implementation for the java.util.Collection interface. The Collection interface has five sub interfaces.Figure 1: The five sub interfaces of the java.util.Collection interface.Set[edit]A set collection contains unique elements, so duplicates are not allowed. It is similar to a mathematical Set. When adding a new item to a set, the set calls the method int hashCode() of the item and compares its result to the hash code of all the already inserted items. If the hash code is not found, the item is added. If the hash code is found, the set calls the boolean equals(Object obj); method for all the set items with the same hashcode as the new item. If all equal-calls return false, the new item is inserted in the set. If an equal-call returns true, the new item is not inserted in the set.Figure 2: Set class diagram.java.util.HashSet<E>\nThis is the basic implementation of the Set interface. Not synchronized. Allows the null elements\njava.util.TreeSet<E>\nElements are sorted, not synchronized. null not allowed\njava.util.CopyOnWriteArraySet<E>\nThread safe, a fresh copy is created during modification operation. Add, update, delete are expensive.\njava.util.EnumSet<E extends Enum<E>>\nAll of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors.\njava.util.LinkedHashSet<E>\nSame as HashSet, plus defines the iteration ordering, which is the order in which elements were inserted into the set.Detecting duplicate objects in Sets[edit]Set cannot have duplicates in it. You may wonder how duplicates are detected when we are adding an object to the Set. We have to see if that object exists in the Set or not. It is not enough to check the object references, the objects' values have to be checked as well.To do that, fortunately, each java object has the boolean equals(Object obj), method available inherited from Object. You need to override it. That method will be called by the Set implementation to compare the two objects to see if they are equal or not.There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared. Calling the equals() method would cause a ClassCastException. There are two solutions to this:Solution one: Override the int hashCode() method and return the same values for the same type of objects and return different values for different type of objects. The equals() method is used to compare objects only with the same value of hashCode. So before an object is added, the Set implementation needs to:\n\nfind all the objects in the Set that have the same hashCode as the candidate object hashCode\nand for those, call the equals() methods passing in the candidate object\nif any of them returns true, the object is not added to the Set.Solution two: Create a super class for the Apple and Orange, let's call it Fruit class. Put Fruits in the Set. You need to do the following:\n\nDo not override the equals() and hashCode() methods in the Apple and Orange classes\nCreate appleEquals() method in the Apple class, and create orangeEquals() method in the Orange class\nOverride the hashCode() method in the Fruit class and return the same value, so the equals() is called by the Set implementation\nOverride the equals() method in the Fruit class for something like this.Code section 5.5: equals method implementation.\n\n\n 1 public boolean equals(Object obj) {\n 2     boolean ret = false;\n 3     if (this instanceof Apple &&\n 4           obj instanceof Apple) {\n 5         ret = this.appleEquals(obj);\n 6     } else if (this instanceof Orange &&\n 7               obj  instanceof Orange) {\n 8         ret = this.orangeEquals(obj);  \n 9     } else {\n10         // Can not compare Orange to Apple\n11        ret = false;\n12     }\n13     return ret;\n14 }Note:Only the objects that have the same hashCode will be compared.\nYou are responsible to override the equals() and hashCode() methods. The default implementations in Object won't work.\nOnly override the hashCode() method if you want to eliminate value duplicates.\nDo not override the hashCode() method if you know that the values of your objects are different, or if you only want to prevent adding the exactly same object.\nBeware that the hashCode() may be used in other collection implementations, like in a Hashtable to find an object fast. Overriding the default hashCode() method may affect performance there.\nThe default hashCodes are unique for each object created, so if you decide not to override the hashCode() method, there is no point overriding the equals() method, as it won't be called.SortedSet[edit]The SortedSet interface is the same as the Set interface plus the elements in the SortedSet are sorted. It extends the Set Interface. All elements in the SortedSet must implement the Comparable Interface, furthermore all elements must be mutually comparable.Note that the ordering maintained by a sorted set must be consistent with equals if the sorted set is to correctly implement the Set interface. This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compare method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal.The SortedSet interface has additional methods due to the sorted nature of the 'Set'. Those are:E first();\nreturns the first element\n\n\nE last();\nreturns the last element\n\n\nSortedSet headSet(E toElement);\nreturns from the first, to the exclusive toElement\n\n\nSortedSet tailSet(E fromElement);\nreturns from the inclusive fromElement to the end\n\n\nSortedSet subSet(E fromElement, E toElement);\nreturns elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned sorted set is empty.)List[edit]In a list collection, the elements are put in a certain order, and can be accessed by an index. Duplicates are allowed, the same element can be added twice to a list. It has the following implementations:Figure 3: List class diagram.java.util.Vector<E>\nSynchronized, use in multiple thread access, otherwise use ArrayList.\njava.util.Stack<E>\nIt extends class Vector with five operations that allow a vector to be treated as a stack. It represents a last-in-first-out (LIFO) stack of objects.\njava.util.ArrayList<E>\nThe basic implementation of the List interface is the ArrayList. The ArrayList is not synchronized, not thread safe. Vector is synchronized, and thread safe. Vector is slower, because of the extra overhead to make it thread safe. When only one thread is accessing the list, use the ArrayList. Whenever you insert or remove an element from the list, there are extra overhead to reindex the list. When you have a large list, and you have lots of insert and remove, consider using the LinkedList.\njava.util.LinkedList<E>\nNon-synchronized, update operation is faster than other lists, easy to use for stacks, queues, double-ended queues. The name LinkedList implies a special data structure where the elements/nodes are connected by pointers.Head               Node 1                   Node 2                     Node n\n  ______\n | Size |          _________________        _______________            _____________\n |______|         |      | point   |       |      | point  |          |      |      |  \n | First|-------->| Data | to next |------>| Data | to next|-- ... -->| Data | null |\n | elem |         |______|_________|       |______|________|          |______|______|\n |______|                                                                 ^\n | Last |                                                                 |\n | elem |-----------------------------------------------------------------\n |______|Each node is related to an item of the linked list. To remove an element from the linked list the pointers need to be rearranged. After removing Node 2:Head               Node 1                   Node 2                     Node n\n  ______                                 _____________________\n | Size |          _________________    |   _______________   |       ______________\n |_- 1__|         |      | point   |    |  |      | point  |  |       |      |      |  \n | First|-------->| Data | to next |----   | Data | to next|   -...-->| Data | null |\n | elem |         |______|_________|       |______|________|          |______|______|\n |______|                                                                 ^\n | Last |                                                                 |\n | elem |-----------------------------------------------------------------\n |______|javax.management.AtributeList<E>\nRepresents a list of values for attributes of an MBean. The methods used for the insertion of Attribute objects in the AttributeList overrides the corresponding methods in the superclass ArrayList. This is needed in order to insure that the objects contained in the AttributeList are only Attribute objects.\njavax.management.relation.RoleList<E>\nA RoleList represents a list of roles (Role objects). It is used as parameter when creating a relation, and when trying to set several roles in a relation (via 'setRoles()' method). It is returned as part of a RoleResult, to provide roles successfully retrieved.\njavax.management.relation.RoleUnresolvedList<E>\nA RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write to roles)."
}