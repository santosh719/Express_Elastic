{
  "title": "The Java bytecodes[edit]",
  "content": "See Oracle's Java Virtual Machine Specification[1] for more detailed descriptionsThe manipulation of the operand stack is notated as [before][after], where [before] is the stack before the instruction is executed and [after] is the stack after the instruction is executed. A stack with the element 'b' on the top and element 'a' just after the top element is denoted 'a,b'.Mnemonic\nOpcode\n(in hex)\nOther bytes\nStack\n[before][after]\nDescription\n\n\nA\n\n\naaload\n32\n\narrayref, index  value\nloads onto the stack a reference from an array\n\n\naastore\n53\n\narrayref, index, value \nstores a reference into an array\n\n\naconst_null\n01\n\n null\npushes a null reference onto the stack\n\n\naload\n19\nindex\n objectref\nloads a reference onto the stack from a local variable #index\n\n\naload_0\n2a\n\n objectref\nloads a reference onto the stack from local variable 0\n\n\naload_1\n2b\n\n objectref\nloads a reference onto the stack from local variable 1\n\n\naload_2\n2c\n\n objectref\nloads a reference onto the stack from local variable 2\n\n\naload_3\n2d\n\n objectref\nloads a reference onto the stack from local variable 3\n\n\nanewarray\nbd\nindexbyte1, indexbyte2\ncount  arrayref\ncreates a new array of references of length count and component type identified by the class reference index (indexbyte1 << 8 + indexbyte2) in the constant pool\n\n\nareturn\nb0\n\nobjectref  [empty]\nreturns a reference from a method\n\n\narraylength\nbe\n\narrayref  length\ngets the length of an array\n\n\nastore\n3a\nindex\nobjectref \nstores a reference into a local variable #index\n\n\nastore_0\n4b\n\nobjectref \nstores a reference into local variable 0\n\n\nastore_1\n4c\n\nobjectref \nstores a reference into local variable 1\n\n\nastore_2\n4d\n\nobjectref \nstores a reference into local variable 2\n\n\nastore_3\n4e\n\nobjectref \nstores a reference into local variable 3\n\n\nathrow\nbf\n\nobjectref  [empty], objectref\nthrows an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)\n\n\nB\n\n\nbaload\n33\n\narrayref, index  value\nloads a byte or Boolean value from an array\n\n\nbastore\n54\n\narrayref, index, value \nstores a byte or Boolean value into an array\n\n\nbipush\n10\nbyte\n value\npushes a byte onto the stack as an integer value\n\n\nC\n\n\ncaload\n34\n\narrayref, index  value\nloads a char from an array\n\n\ncastore\n55\n\narrayref, index, value \nstores a char into an array\n\n\ncheckcast\nc0\nindexbyte1, indexbyte2\nobjectref  objectref\nchecks whether an objectref is of a certain type, the class reference of which is in the constant pool at index (indexbyte1 << 8 + indexbyte2)\n\n\nD\n\n\nd2f\n90\n\nvalue  result\nconverts a double to a float\n\n\nd2i\n8e\n\nvalue  result\nconverts a double to an int\n\n\nd2l\n8f\n\nvalue  result\nconverts a double to a long\n\n\ndadd\n63\n\nvalue1, value2  result\nadds two doubles\n\n\ndaload\n31\n\narrayref, index  value\nloads a double from an array\n\n\ndastore\n52\n\narrayref, index, value \nstores a double into an array\n\n\ndcmpg\n98\n\nvalue1, value2  result\ncompares two doubles\n\n\ndcmpl\n97\n\nvalue1, value2  result\ncompares two doubles\n\n\ndconst_0\n0e\n\n 0.0\npushes the constant 0.0 onto the stack\n\n\ndconst_1\n0f\n\n 1.0\npushes the constant 1.0 onto the stack\n\n\nddiv\n6f\n\nvalue1, value2  result\ndivides two doubles\n\n\ndload\n18\nindex\n value\nloads a double value from a local variable #index\n\n\ndload_0\n26\n\n value\nloads a double from local variable 0\n\n\ndload_1\n27\n\n value\nloads a double from local variable 1\n\n\ndload_2\n28\n\n value\nloads a double from local variable 2\n\n\ndload_3\n29\n\n value\nloads a double from local variable 3\n\n\ndmul\n6b\n\nvalue1, value2  result\nmultiplies two doubles\n\n\ndneg\n77\n\nvalue  result\nnegates a double\n\n\ndrem\n73\n\nvalue1, value2  result\ngets the remainder from a division between two doubles\n\n\ndreturn\naf\n\nvalue  [empty]\nreturns a double from a method\n\n\ndstore\n39\nindex\nvalue \nstores a double value into a local variable #index\n\n\ndstore_0\n47\n\nvalue \nstores a double into local variable 0\n\n\ndstore_1\n48\n\nvalue \nstores a double into local variable 1\n\n\ndstore_2\n49\n\nvalue \nstores a double into local variable 2\n\n\ndstore_3\n4a\n\nvalue \nstores a double into local variable 3\n\n\ndsub\n67\n\nvalue1, value2  result\nsubtracts a double from another\n\n\ndup\n59\n\nvalue  value, value\nduplicates the value on top of the stack\n\n\ndup_x1\n5a\n\nvalue2, value1  value1, value2, value1\ninserts a copy of the top value into the stack two values from the top\n\n\ndup_x2\n5b\n\nvalue3, value2, value1  value1, value3, value2, value1\ninserts a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top\n\n\ndup2\n5c\n\n{value2, value1}  {value2, value1}, {value2, value1}\nduplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)\n\n\ndup2_x1\n5d\n\nvalue3, {value2, value1}  {value2, value1}, value3, {value2, value1}\nduplicate two words and insert beneath third word (see explanation above)\n\n\ndup2_x2\n5e\n\n{value4, value3}, {value2, value1}  {value2, value1}, {value4, value3}, {value2, value1}\nduplicate two words and insert beneath fourth word\n\n\nF\n\n\nf2d\n8d\n\nvalue  result\nconverts a float to a double\n\n\nf2i\n8b\n\nvalue  result\nconverts a float to an int\n\n\nf2l\n8c\n\nvalue  result\nconverts a float to a long\n\n\nfadd\n62\n\nvalue1, value2  result\nadds two floats\n\n\nfaload\n30\n\narrayref, index  value\nloads a float from an array\n\n\nfastore\n51\n\narreyref, index, value \nstores a float in an array\n\n\nfcmpg\n96\n\nvalue1, value2  result\ncompares two floats\n\n\nfcmpl\n95\n\nvalue1, value2  result\ncompares two floats\n\n\nfconst_0\n0b\n\n 0.0f\npushes 0.0f on the stack\n\n\nfconst_1\n0c\n\n 1.0f\npushes 1.0f on the stack\n\n\nfconst_2\n0d\n\n 2.0f\npushes 2.0f on the stack\n\n\nfdiv\n6e\n\nvalue1, value2  result\ndivides two floats\n\n\nfload\n17\nindex\n value\nloads a float value from a local variable #index\n\n\nfload_0\n22\n\n value\nloads a float value from local variable 0\n\n\nfload_1\n23\n\n value\nloads a float value from local variable 1\n\n\nfload_2\n24\n\n value\nloads a float value from local variable 2\n\n\nfload_3\n25\n\n value\nloads a float value from local variable 3\n\n\nfmul\n6a\n\nvalue1, value2  result\nmultiplies two floats\n\n\nfneg\n76\n\nvalue  result\nnegates a float\n\n\nfrem\n72\n\nvalue1, value2  result\ngets the remainder from a division between two floats\n\n\nfreturn\nae\n\nvalue  [empty]\nreturns a float from method\n\n\nfstore\n38\nindex\nvalue \nstores a float value into a local variable #index\n\n\nfstore_0\n43\n\nvalue \nstores a float value into local variable 0\n\n\nfstore_1\n44\n\nvalue \nstores a float value into local variable 1\n\n\nfstore_2\n45\n\nvalue \nstores a float value into local variable 2\n\n\nfstore_3\n46\n\nvalue \nstores a float value into local variable 3\n\n\nfsub\n66\n\nvalue1, value2  result\nsubtracts two floats\n\n\nG\n\n\ngetfield\nb4\nindex1, index2\nobjectref  value\ngets a field value of an object objectref, where the field is identified by field reference in the constant pool index (index1 << 8 + index2)\n\n\ngetstatic\nb2\nindex1, index2\n value\ngets a static field value of a class, where the field is identified by field reference in the constant pool index (index1 << 8 + index2)\n\n\ngoto\na7\nbranchbyte1, branchbyte2\n[no change]\ngoes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\ngoto_w\nc8\nbranchbyte1, branchbyte2, branchbyte3, branchbyte4\n[no change]\ngoes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4)\n\n\nI\n\n\ni2b\n91\n\nvalue  result\nconverts an int into a byte\n\n\ni2c\n92\n\nvalue  result\nconverts an int into a character\n\n\ni2d\n87\n\nvalue  result\nconverts an int into a double\n\n\ni2f\n86\n\nvalue  result\nconverts an int into a float\n\n\ni2l\n85\n\nvalue  result\nconverts an int into a long\n\n\ni2s\n93\n\nvalue  result\nconverts an int into a short\n\n\niadd\n60\n\nvalue1, value2  result\nadds two ints together\n\n\niaload\n2e\n\narrayref, index  value\nloads an int from an array\n\n\niand\n7e\n\nvalue1, value2  result\nperforms a logical and on two integers\n\n\niastore\n4f\n\narrayref, index, value \nstores an int into an array\n\n\niconst_m1\n02\n\n -1\nloads the int value -1 onto the stack\n\n\niconst_0\n03\n\n 0\nloads the int value 0 onto the stack\n\n\niconst_1\n04\n\n 1\nloads the int value 1 onto the stack\n\n\niconst_2\n05\n\n 2\nloads the int value 2 onto the stack\n\n\niconst_3\n06\n\n 3\nloads the int value 3 onto the stack\n\n\niconst_4\n07\n\n 4\nloads the int value 4 onto the stack\n\n\niconst_5\n08\n\n 5\nloads the int value 5 onto the stack\n\n\nidiv\n6c\n\nvalue1, value2  result\ndivides two integers\n\n\nif_acmpeq\na5\nbranchbyte1, branchbyte2\nvalue1, value2 \nif references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_acmpne\na6\nbranchbyte1, branchbyte2\nvalue1, value2 \nif references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpeq\n9f\nbranchbyte1, branchbyte2\nvalue1, value2 \nif ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpne\na0\nbranchbyte1, branchbyte2\nvalue1, value2 \nif ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmplt\na1\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpge\na2\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpgt\na3\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmple\na4\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifeq\n99\nbranchbyte1, branchbyte2\nvalue \nif value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifne\n9a\nbranchbyte1, branchbyte2\nvalue \nif value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\niflt\n9b\nbranchbyte1, branchbyte2\nvalue \nif value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifge\n9c\nbranchbyte1, branchbyte2\nvalue \nif value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifgt\n9d\nbranchbyte1, branchbyte2\nvalue \nif value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifle\n9e\nbranchbyte1, branchbyte2\nvalue \nif value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifnonnull\nc7\nbranchbyte1, branchbyte2\nvalue \nif value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifnull\nc6\nbranchbyte1, branchbyte2\nvalue \nif value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\niinc\n84\nindex, const\n[No change]\nincrement local variable #index by signed byte const\n\n\niload\n15\nindex\n value\nloads an int value from a variable #index\n\n\niload_0\n1a\n\n value\nloads an int value from variable 0\n\n\niload_1\n1b\n\n value\nloads an int value from variable 1\n\n\niload_2\n1c\n\n value\nloads an int value from variable 2\n\n\niload_3\n1d\n\n value\nloads an int value from variable 3\n\n\nimul\n68\n\nvalue1, value2  result\nmultiply two integers\n\n\nineg\n74\n\nvalue  result\nnegate int\n\n\ninstanceof\nc1\nindexbyte1, indexbyte2\nobjectref  result\ndetermines if an object objectref is of a given type, identified by class reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\ninvokeinterface\nb9\nindexbyte1, indexbyte2, count, 0\nobjectref, [arg1, arg2, ...] \ninvokes an interface method on object objectref, where the interface method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2) and count is the number of arguments to pop from the stack frame including the object on which the method is being called and must always be greater than or equal to 1\n\n\ninvokespecial\nb7\nindexbyte1, indexbyte2\nobjectref, [arg1, arg2, ...] \ninvoke instance method on object objectref requiring special handling (instance initialization method, a private method, or a superclass method), where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\ninvokestatic\nb8\nindexbyte1, indexbyte2\n[arg1, arg2, ...] \ninvoke a static method, where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\ninvokevirtual\nb6\nindexbyte1, indexbyte2\nobjectref, [arg1, arg2, ...] \ninvoke virtual method on object objectref, where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\nior\n80\n\nvalue1, value2  result\nlogical int or\n\n\nirem\n70\n\nvalue1, value2  result\nlogical int remainder\n\n\nireturn\nac\n\nvalue  [empty]\nreturns an integer from a method\n\n\nishl\n78\n\nvalue1, value2  result\nint shift left\n\n\nishr\n7a\n\nvalue1, value2  result\nint shift right\n\n\nistore\n36\nindex\nvalue \nstore int value into variable #index\n\n\nistore_0\n3b\n\nvalue \nstore int value into variable 0\n\n\nistore_1\n3c\n\nvalue \nstore int value into variable 1\n\n\nistore_2\n3d\n\nvalue \nstore int value into variable 2\n\n\nistore_3\n3e\n\nvalue \nstore int value into variable 3\n\n\nisub\n64\n\nvalue1, value2  result\nint subtract\n\n\niushr\n7c\n\nvalue1, value2  result\nint shift right\n\n\nixor\n82\n\nvalue1, value2  result\nint xor\n\n\nJ\n\n\njsr\na8\nbranchbyte1, branchbyte2\n address\njump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2) and place the return address on the stack\n\n\njsr_w\nc9\nbranchbyte1, branchbyte2, branchbyte3, branchbyte4\n address\njump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack\n\n\nL\n\n\nl2d\n8a\n\nvalue  result\nconverts a long to a double\n\n\nl2f\n89\n\nvalue  result\nconverts a long to a float\n\n\nl2i\n88\n\nvalue  result\nconverts a long to an int\n\n\nladd\n61\n\nvalue1, value2  result\nadd two longs\n\n\nlaload\n2f\n\narrayref, index  value\nload a long from an array\n\n\nland\n7f\n\nvalue1, value2  result\nbitwise and of two longs\n\n\nlastore\n50\n\narrayref, index, value \nstore a long to an array\n\n\nlcmp\n94\n\nvalue1, value2  result\ncompares two longs values\n\n\nlconst_0\n09\n\n 0L\npushes the long 0 onto the stack\n\n\nlconst_1\n0a\n\n 1L\npushes the long 1 onto the stack\n\n\nldc\n12\nindex\n value\npushes a constant #index from a constant pool (String, int, float or class type) onto the stack\n\n\nldc_w\n13\nindexbyte1, indexbyte2\n value\npushes a constant #index from a constant pool (String, int, float or class type) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)\n\n\nldc2_w\n14\nindexbyte1, indexbyte2\n value\npushes a constant #index from a constant pool (double or long) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)\n\n\nldiv\n6d\n\nvalue1, value2  result\ndivide two longs\n\n\nlload\n16\nindex\n value\nload a long value from a local variable #index\n\n\nlload_0\n1e\n\n value\nload a long value from a local variable 0\n\n\nlload_1\n1f\n\n value\nload a long value from a local variable 1\n\n\nlload_2\n20\n\n value\nload a long value from a local variable 2\n\n\nlload_3\n21\n\n value\nload a long value from a local variable 3\n\n\nlmul\n69\n\nvalue1, value2  result\nmultiplies two longs\n\n\nlneg\n75\n\nvalue  result\nnegates a long\n\n\nlookupswitch\nab\n<0-3 bytes padding>, defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, npairs3, npairs4, match-offset pairs...\nkey \na target address is looked up from a table using a key and execution continues from the instruction at that address\n\n\nlor\n81\n\nvalue1, value2  result\nbitwise or of two longs\n\n\nlrem\n71\n\nvalue1, value2  result\nremainder of division of two longs\n\n\nlreturn\nad\n\nvalue  [empty]\nreturns a long value\n\n\nlshl\n79\n\nvalue1, value2  result\nbitwise shift left of a long value1 by value2 positions\n\n\nlshr\n7b\n\nvalue1, value2  result\nbitwise shift right of a long value1 by value2 positions\n\n\nlstore\n37\nindex\nvalue \nstore a long value in a local variable #index\n\n\nlstore_0\n3f\n\nvalue \nstore a long value in a local variable 0\n\n\nlstore_1\n40\n\nvalue \nstore a long value in a local variable 1\n\n\nlstore_2\n41\n\nvalue \nstore a long value in a local variable 2\n\n\nlstore_3\n42\n\nvalue \nstore a long value in a local variable 3\n\n\nlsub\n65\n\nvalue1, value2  result\nsubtract two longs\n\n\nlushr\n7d\n\nvalue1, value2  result\nbitwise shift right of a long value1 by value2 positions, unsigned\n\n\nlxor\n83\n\nvalue1, value2  result\nbitwise exclusive or of two longs\n\n\nM\n\n\nmonitorenter\nc2\n\nobjectref \nenter monitor for object (\"grab the lock\" - start of synchronized() section)\n\n\nmonitorexit\nc3\n\nobjectref \nexit monitor for object (\"release the lock\" - end of synchronized() section)\n\n\nmultianewarray\nc5\nindexbyte1, indexbyte2, dimensions\ncount1, [count2,...]  arrayref\ncreate a new array of dimensions dimensions with elements of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc]\n\n\nN\n\n\nnew\nbb\nindexbyte1, indexbyte2\n objectref\ncreates new object of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2)\n\n\nnewarray\nbc\natype\ncount  arrayref\ncreates new array with count elements of primitive type identified by atype\n\n\nnop\n00\n\n[No change]\nperforms no operation\n\n\nP\n\n\npop\n57\n\nvalue \ndiscards the top value on the stack\n\n\npop2\n58\n\n{value2, value1} \ndiscards the top two values on the stack (or one value, if it is a double or long)\n\n\nputfield\nb5\nindexbyte1, indexbyte2\nobjectref, value \nset field to value in an object objectref, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\nputstatic\nb3\nindexbyte1, indexbyte2\nvalue \nset static field to value in a class, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\nR\n\n\nret\na9\nindex\n[No change]\ncontinue execution from address taken from a local variable #index (the asymmetry with jsr is intentional)\n\n\nreturn\nb1\n\n [empty]\nreturn void from method\n\n\nS\n\n\nsaload\n35\n\narrayref, index  value\nload short from array\n\n\nsastore\n56\n\narrayref, index, value \nstore short to array\n\n\nsipush\n11\nbyte1, byte2\n value\npushes a signed integer (byte1 << 8 + byte2) onto the stack\n\n\nswap\n5f\n\nvalue2, value1  value1, value2\nswaps two top words on the stack (note that value1 and value2 must not be double or long)\n\n\nT\n\n\ntableswitch\naa\n[0-3 bytes padding], defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, jump offsets...\nindex \ncontinue execution from an address in the table at offset index\n\n\nW\n\n\nwide\nc4\nopcode, indexbyte1, indexbyte2\nor\niinc, indexbyte1, indexbyte2, countbyte1, countbyte2\n[same as for corresponding instructions]\nexecute opcode, where opcode is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume the index is 16 bit; or execute iinc, where the index is 16 bits and the constant to increment by is a signed 16 bit short\n\n\nUnused\n\n\nbreakpoint\nca\n\n\nreserved for breakpoints in Java debuggers; should not appear in any class file\n\n\nimpdep1\nfe\n\n\nreserved for implementation-dependent operations within debuggers; should not appear in any class file\n\n\nimpdep2\nff\n\n\nreserved for implementation-dependent operations within debuggers; should not appear in any class file\n\n\n(no name)\ncb-fd\n\n\nthese values are currently unassigned for opcodes and are reserved for future use\n\n\nxxxunusedxxx\nba\n\n\nthis opcode is reserved \"for historical reasons\""
}